#[cfg(test)]
mod tests {
    use crate::EthProver;
    use hex::{FromHex, ToHex};
    use near_sdk::PromiseOrValue;
    use rlp::RlpStream;
    use serde::{Deserialize, Deserializer};

    #[derive(Debug)]
    struct Hex(pub Vec<u8>);

    impl<'de> Deserialize<'de> for Hex {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            let mut s = <String as Deserialize>::deserialize(deserializer)?;
            if s.starts_with("0x") {
                s = s[2..].to_string();
            }
            if s.len() % 2 == 1 {
                s.insert_str(0, "0");
            }
            Ok(Hex(Vec::from_hex(&s).map_err(|err| {
                serde::de::Error::custom(err.to_string())
            })?))
        }
    }

    // TESTS

    use borsh::BorshSerialize;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.near".to_string(),
            signer_account_id: "bob.near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "carol.near".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            epoch_height: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
        }
    }

    #[test]
    fn simple_tx_res() {
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        // Following data could be extracted by:
        // NODE_URL="https://mainnet.infura.io/v3/b5f870422ee5454fb11937e947154cd2" TX_HASH="0xb540248a9cca048c5861dec953d7a776bc1944319b9bd27a462469c8a437f4ff" EVENT_INDEX=0 node extract.js

        let log_index = 0;
        let receipt_index = 0;
        let header_data = Vec::from_hex("f9021aa0f779e50b45bc27e4ed236840e5dbcf7afab50beaf553be56bf76da977e10cc73a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d493479452bc44d5378309ee2abf1539bf71de1b7d7be3b5a014c996b6934d7991643669e145b8355c63aa02cbde63d390fcf4e6181d5eea45a079b7e79dc739c31662fe6f25f65bf5a5d14299c7a7aa42c3f75b9fb05474f54ca0e28dc05418692cb7baab7e7f85c1dedb8791c275b797ea3b1ffcaec5ef2aa271b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000903234373439353837313930323034343383890fe68395ba8e82d0d9845dd84a079150505945206e616e6f706f6f6c2e6f7267a0a35425f443452cf94ba4b698b00fd7b3ff4fc671dea3d5cc2dcbedbc3766f45e88af7fec6031063a17").unwrap();
        let receipt_data = Vec::from_hex("f901a60182d0d9b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000006cc5f688a315f3dc28a7781717a9a798a59fda7ba00000000000000000000000007e7a32d9dc98c485c489be8e732f97b4ffe3a4cda000000000000000000000000000000000000000000000000000000001a13b8600").unwrap();
        let log_entry = Vec::from_hex("f89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000006cc5f688a315f3dc28a7781717a9a798a59fda7ba00000000000000000000000007e7a32d9dc98c485c489be8e732f97b4ffe3a4cda000000000000000000000000000000000000000000000000000000001a13b8600").unwrap();
        let proof = vec![
        vec![
            Vec::from_hex("2080").unwrap(),
            Vec::from_hex("f901a60182d0d9b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000006cc5f688a315f3dc28a7781717a9a798a59fda7ba00000000000000000000000007e7a32d9dc98c485c489be8e732f97b4ffe3a4cda000000000000000000000000000000000000000000000000000000001a13b8600").unwrap(),
        ],
    ].iter().map(|node| {
        let mut stream = RlpStream::new();
        stream.begin_list(node.len());
        for item in node {
            stream.append(item);
        }
        stream.out()
    }).collect();

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn complex_tx_res() {
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        // Following data could be extracted by:
        // NODE_URL="https://mainnet.infura.io/v3/b5f870422ee5454fb11937e947154cd2" TX_HASH="0xa7e1633e8099ea2b72496207b76a0e04a761c52f48c82bfcf6b327495258e4e0" EVENT_INDEX=0 node extract.js

        let log_index = 0;
        let receipt_index = 190;
        let header_data = Vec::from_hex("f9021ea059822ac0f17af7578ac8cf2c655a4ccfb1f5622ecad88992a2522e91a3cc401da01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d4934794829bd824b016326a401d083b33d092293333a830a01f54c61cebc3d08954929f359668498e191c1a34adb47f5db2881d414b69631ca0adf860aabb9786198a7d91dec6514ecebfd5aba4565fb7a81f8e68cf819b3000a0dddbc1d4cc2f1f522a3ba1f627d7645945d4922d6eb82c318c7be64735ec0e0db901000416012000c9a88c580040302001880844228042b418e12800bd011510a9580700f15880012010400858c08042dab1408b200403c1484425ac90c800d02c0800050050c04b4cc4b01083211905c820409a000e0c1346200508024c8020c892907120102c0a2840332290050028808c2104611a0c90944a020c002853968810640c0190030c342500584004239a2704228212001dc80004016803a15610920180070c89000a802115094a4082450080522001318488a8098a08c28000188025580490a4aa00b2802012001050868800140d0fd20800d8200682226060119420049032000832001a4011780096081c7654002800100d9484102144ec889094a44a903233363631373837353134373338393883984f928398684283986153845eac64b1947070796520e4b883e5bda9e7a59ee4bb99e9b1bca0814ab4871d625ff894a6736dcf195f4ce1c0f5dd8a3d42a1e9587c2a9e1d522988dd7482ba86e3b14a").unwrap();
        let receipt_data = Vec::from_hex("f901a701839590b6b9010000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000001000000000000000000000000000000010000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000004000000000000000010000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000600000000000f89df89b945885d2a27bd4c6d111b83bc3fc359ed951e8e6f8f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000009b24ee0bfbf708b541fb65b6087d6e991a0d11a8a00000000000000000000000005a012de1a4c89b496e0a276158552abe6f843a6fa0000000000000000000000000000000000000000000000001135631d5283a4000").unwrap();
        let log_entry = Vec::from_hex("f89b945885d2a27bd4c6d111b83bc3fc359ed951e8e6f8f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000009b24ee0bfbf708b541fb65b6087d6e991a0d11a8a00000000000000000000000005a012de1a4c89b496e0a276158552abe6f843a6fa0000000000000000000000000000000000000000000000001135631d5283a4000").unwrap();
        let proof = vec![
        vec![
            Vec::from_hex("c684a63b18c933f0b45d6863ec63d5beb49e191992479fe3cbf1dc6709661337").unwrap(),
            Vec::from_hex("297cb12d9b6b25bff0bd3199bfd2fdb4b3fca45416ecc355958b68dc1b7bc7a3").unwrap(),
            Vec::from_hex("870bde7cc109d51463b1b8e77ebb36cb4021ddc7df0fd31c3140cad3260236e8").unwrap(),
            Vec::from_hex("8ddcf32ce5a1ac912bddc28f2f25df0921aaff8f100f2979028b27baa5b191f1").unwrap(),
            Vec::from_hex("4de7d3b04b549af847ffcc757f8aa121b02bd00c1233e90547fac99da7049e19").unwrap(),
            Vec::from_hex("206564eec53442ea3334438820c75c1f8bdb617430956f07a08e66f5990458ae").unwrap(),
            Vec::from_hex("b11876d993891898b6397d0fa744783ba5bf35e79a329c7b9710e9026c2957c8").unwrap(),
            Vec::from_hex("719cc527cb7fcec3efaf017c5c4801609fa41572befae0468c24ac48fd389437").unwrap(),
            Vec::from_hex("e59bf6fa8f9359d07651b581b3875fc8aea5b85ba0eab9e23503dfa273b9b0f0").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("a123f503897e190fa46ac478716778ebff6c1661b676c910cb4d4c6764457e06").unwrap(),
            Vec::from_hex("4ca92d89e85b0bc5a8670844967a027f012db12fb027808532c0ad61a751747e").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("578357a5e1c44fdccf2cc34d27142b04ec433fe3c8bc57a35c4971f6a82a4da4").unwrap(),
            Vec::from_hex("4d6d3155937f76f01a359ebff4336a504ede8e283e555e1194468883854b7b11").unwrap(),
            Vec::from_hex("ce5478625cca3b625badaa26d231cbd072735b72307b7bce43a7917bd8ba04be").unwrap(),
            Vec::from_hex("66d11ae6215298daa654e04de8649aeb1e116f7138bf3d921c5cbe0a52589116").unwrap(),
            Vec::from_hex("e80733626a805d2974d9b97db52e18d2ce28f532f96552098bf0e656c6bb39a9").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("46935fcc8ffcc89c8eae03fef89ac9fbde75be14b64c810fb1447d328907456d").unwrap(),
            Vec::from_hex("15ec39ed1284cdf4840d6b7511ff34aed164fd9e4b920b1fdb6fde54958d3a17").unwrap(),
            Vec::from_hex("e02aae4672f8b80f468759b092e4eb809edc8cf4b513df11b21d4233556c0b4d").unwrap(),
            Vec::from_hex("0efe37f3d3919b0bed73152bee545e033eb1fad5ddd8e383747decfd5ae93231").unwrap(),
            Vec::from_hex("16616fa5c192ddf9d0c2e1b1d70dc02a83f490b7d729072ac129d9f58f1e166d").unwrap(),
            Vec::from_hex("edb363ac38c62779bf449b0a51bb0b79a9541e8e5b12a8660185fa729795bedc").unwrap(),
            Vec::from_hex("c59dfcdfefed6a01b761ffd820cec8b8f52d9cb287759441cbd73e2a78ba2416").unwrap(),
            Vec::from_hex("893e6dacc036de93725e0e5112d849a735837a94536635318227b448535c6eb2").unwrap(),
            Vec::from_hex("dd8b4c24d7246d9c3a86fef130a5a3bc53f10d1ab706789d6914b8580c4c0202").unwrap(),
            Vec::from_hex("17c0abe1c74e0d01db47e4e2f2d75555d0ea3a2fc590670186ac23dd31944ec0").unwrap(),
            Vec::from_hex("4535f5fc448300be236c1e7f28576296b449592f5adbac59bf35a40e2f7701be").unwrap(),
            Vec::from_hex("bbf8eca1063220d003071437da87689887491c999913f5aba6ed21915c78407c").unwrap(),
            Vec::from_hex("1875e64c3cb31254ff0cf8041d4053c33e3f6aad8faad2c9323729324eaf1a9e").unwrap(),
            Vec::from_hex("7546cbb2b0137e669738c5ab69fb2071f755b253468f90da48855d41411d2e77").unwrap(),
            Vec::from_hex("d9677df9ddf784f9d20f24737b40cb372478114b225df8af225c0f40aaa843f5").unwrap(),
            Vec::from_hex("5b34e3dcfa33c72c4645793531246a91b74af04d564eebd63d00d0e274880283").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("20").unwrap(),
            Vec::from_hex("f901a701839590b6b9010000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000001000000000000000000000000000000010000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000004000000000000000010000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000600000000000f89df89b945885d2a27bd4c6d111b83bc3fc359ed951e8e6f8f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000009b24ee0bfbf708b541fb65b6087d6e991a0d11a8a00000000000000000000000005a012de1a4c89b496e0a276158552abe6f843a6fa0000000000000000000000000000000000000000000000001135631d5283a4000").unwrap(),
        ],
    ].iter().map(|node| {
        let mut stream = RlpStream::new();
        stream.begin_list(node.len());
        for item in node {
            stream.append(item);
        }
        stream.out()
    }).collect();

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn complex_test2() {
        let log_index = 0;
        let receipt_index = 1;
        let header_data = Vec::from_hex("f9021aa0fbc31be764b2ba0eb7ee8ac2ce71743a9643772960eca29751c014e21de21278a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347945a0b54d5dc17e0aadc383d2db43b0a0d3e029c4ca0f35ea6f9f8a4a6bd6338ded9e4835c5111e3de7d78ec3869bba35e8db64f98a1a03990dcdacdec9c2626acb9b7c45c4fb5ddf62e61fd03151940f459da6f995345a0b23d76b7b3747e862bb148796a84697aed7ae4f493bdc6e8fd86fabc15c2076cb9010020e29a9a88c12d9ce049f610e00016230089010014ada31c62437913062aabdc310b8558216215f4045742123241a30d963087246804068307c1514017e839815c000020829cdc00eb84d10f87c0dd384d83a502822ae0289b28b40dc845307c536088a1125242c00788626840062910dd4e183418a2411c0ca1d412e0709cc70339c0052345e08920a15e05a6c264b10808375949a20c6ec6ce016204b50011077da58a0ac92e5a1e07a486512fb332d1239dd5e85890e0005863101c9108651430a0e300090a00945b4d13876310242804da061c2d149008910001340c61004c113565f1321cde85a24c3cf27dfa4450c84010d01156d0084fb4350886a8ea9032323433303231373839313735313932839a1acc839895ff839848c0845ec4709a906574682d70726f2d687a682d74303032a00bdd7eaec7aa518470d8fc2c9c3ce9b20ae81cbd6e9a7697e7b6955eafbe71448825e70b4c039f477c").unwrap();
        let receipt_data = Vec::from_hex("f901a70183012d99b9010000000000000000000000000000000000000001000000000000000000000000000000000000000000000002000000010000000000000000000000000000000000000000000008000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000400000000000000000000000000000000000000000000000000100000000000000000000004000080000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000adb2b42f6bd96f5c65920b9ac88619dce4166f94a0000000000000000000000000658a36d8f840f73207af8df717d12046b2c75969a000000000000000000000000000000000000000000000000000000000042c1d80").unwrap();
        let log_entry = Vec::from_hex("f89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000adb2b42f6bd96f5c65920b9ac88619dce4166f94a0000000000000000000000000658a36d8f840f73207af8df717d12046b2c75969a000000000000000000000000000000000000000000000000000000000042c1d80").unwrap();

        let proof = vec![
    vec![
        Vec::from_hex("7ea815c3bb71385b7a510e4982f8313c587df3e089ff5f10ef0b56c36071181a").unwrap(),
        Vec::from_hex("aed4d27efd05e63eef759ea509eab454e0af48bee830df3e35555bb0a286d231").unwrap(),
        Vec::from_hex("33e390a966c516979815c1f2017dbbced85a051ee1fa80f3e1ec53cf1c9cdd2a").unwrap(),
        Vec::from_hex("42b428567467e5185275855e1785c8b8d7f9bc3a43f1be769d770eea3fc20406").unwrap(),
        Vec::from_hex("6dddd3c9259c9ada25d4e3e6597e418c57cb02a161efbba40769e1d581abe20c").unwrap(),
        Vec::from_hex("e218b0ea18d0ecdaa79c39d116ca13b3d3d46681b6d05dcacc6240157b13fc11").unwrap(),
        Vec::from_hex("ec966a6c704f311620c3edad1afb82142ffe26e0c72e663bdd1b19395adbeac9").unwrap(),
        Vec::from_hex("648364b261369d14558bace2ba9ff2297140d175d126ec3523c6678d24186c78").unwrap(),
        Vec::from_hex("fa7687bf5494e940497877b0af984a3a6d2881540b38f3a7022a727541f7e640").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),

    ],
    vec![
        Vec::from_hex("").unwrap(),
        Vec::from_hex("b41ef42ebd5a54a9834eb215c8e3cbe05d71ced9ee5ff465801759362925099e").unwrap(),
        Vec::from_hex("65694c678def4a1be4a2c33fbe9a039028ba07239eea62cac48311aad9f6f744").unwrap(),
        Vec::from_hex("2788302a6da4394430ae76b909dcb3470562cc4f2beb34dd84910214098c2dd4").unwrap(),
        Vec::from_hex("dc2bca155d607e3ab7a50568ab6a5861730ee59aff6eb883a578c6766e318cb5").unwrap(),
        Vec::from_hex("17ccd6e58a09d12b854aa1dfd945e9ac4861ac61346326351c7807ed3a6cd166").unwrap(),
        Vec::from_hex("9c49c49ed1cc4713b965a2b469b8e00b2a4ec15fd738a58d70f57413c8543265").unwrap(),
        Vec::from_hex("52292a51a81001bd97ab317d573b43c00a2fe9cbe2b71e8b6f867fc71e3d9acc").unwrap(),
        Vec::from_hex("a6e6de2a96567b42ac6ddd29a46fa75fba4e3a6bd2edfdcc5102eaa030c821e0").unwrap(),
        Vec::from_hex("c9da26cf4ddb9aa33f52ab0e8c0da91dd56b0c346f804c5db1411167f32cf23a").unwrap(),
        Vec::from_hex("2cf55c3104a836212f679521a3e7ac2202180e2568186e09d419dec6af598830").unwrap(),
        Vec::from_hex("6b5b12b7e5858accef4ba7a9e243f0b7eac91aa4a5080bd7b68e0c64b5cedccf").unwrap(),
        Vec::from_hex("ed32579f4c42503e20c6b356228664c1d5e28f3237bf8e8878e53fe910e9a356").unwrap(),
        Vec::from_hex("ccf3014a6bccf8a6d0ed97fc0a7d4e53a3d1c75d784625c2e556c8dd5a9e5a06").unwrap(),
        Vec::from_hex("aab295d8f316e3bbb6e26d77ce71ea7d96f0c8b28aea132856291e46f4a653d8").unwrap(),
        Vec::from_hex("85b056f6837537036e5862e567beadc46c9c76bbfe43024cae7c561547fdcf2e").unwrap(),
        Vec::from_hex("").unwrap(),
    ],
    vec![
        Vec::from_hex("20").unwrap(),
        Vec::from_hex("f901a70183012d99b9010000000000000000000000000000000000000001000000000000000000000000000000000000000000000002000000010000000000000000000000000000000000000000000008000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000400000000000000000000000000000000000000000000000000100000000000000000000004000080000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000adb2b42f6bd96f5c65920b9ac88619dce4166f94a0000000000000000000000000658a36d8f840f73207af8df717d12046b2c75969a000000000000000000000000000000000000000000000000000000000042c1d80").unwrap(),
    ],
    ];
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        let proof = proof
            .iter()
            .map(|node| {
                let mut stream = RlpStream::new();
                stream.begin_list(node.len());
                for item in node {
                    stream.append(item);
                }
                stream.out()
            })
            .collect();

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn complex_test3() {
        let log_index = 0;
        let receipt_index = 0;
        let header_data = Vec::from_hex("f90211a0460c84f2877fd351416cc9207bbb140eda2a59f0501bda5d4e814e017024536fa01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347948595dd9e0438640b5e1254f9df579ac12a86865fa0c2377ee7587692810e987464064b2247c8d7d6ad0f9fce327bd27ad0c92a62afa0a4041a7e77fc216726e5015e6712d6434a1a4991781ed9478f5451ad5ac1e362a077ee012c7ec8a7a5cc6f8c7899e4176f8716ce11c637820d84a09e2b548191d3b90100000000000000001000000000000000000000000000100000000000000000000000000040000000000000000000400100000000000000000000000000800000000000000000000000000020080000040000000000000000000000000000100000000000000000400000080000000000000000000000000000000000100000000000000000000000000000000000004000000000000000000000020000001000000000000000000000000000800000000000000000000000000000000004000000000000020000280000000000000800000500000100000000400000200000000000800000000000000000000000000000020000000000000000000000040000009032323137373831393836303031333938839a4aa383979f3e83024c39845ec6f2f487657a696c2e6d65a0f0a64ca3c939e2506d05505449b4caaa06eba7c86062997e6632b0ee3db977df88e284f1c803fa6f5a").unwrap();
        let receipt_data = Vec::from_hex("f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000").unwrap();
        let log_entry = Vec::from_hex("f89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000").unwrap();
        let proof = vec![
    vec![
        Vec::from_hex("6adc4881ae9f2b2bbbf70a60e5b05f0734c02d731e80ac1503231d851b24ffe6").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("103165b38cd8ad3ffa4b1de70e7391ac2c321ffe265bc77f2316ba33288c3717").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
    ],
    vec![
        Vec::from_hex("30").unwrap(),
        Vec::from_hex("f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000").unwrap(),
    ]];

        let proof: Vec<Vec<u8>> = proof
            .iter()
            .map(|node| {
                let mut stream = RlpStream::new();
                stream.begin_list(node.len());
                for item in node {
                    stream.append(item);
                }
                stream.out()
            })
            .collect();

        let actual_borsh_log_index = "0000000000000000";
        let actual_borsh_log_entry_data = "9d000000f89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000";
        let actual_borsh_receipt_index = "0000000000000000";
        let actual_borsh_receipt_data = "a9010000f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000";
        let actual_borsh_header_data = "14020000f90211a0460c84f2877fd351416cc9207bbb140eda2a59f0501bda5d4e814e017024536fa01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347948595dd9e0438640b5e1254f9df579ac12a86865fa0c2377ee7587692810e987464064b2247c8d7d6ad0f9fce327bd27ad0c92a62afa0a4041a7e77fc216726e5015e6712d6434a1a4991781ed9478f5451ad5ac1e362a077ee012c7ec8a7a5cc6f8c7899e4176f8716ce11c637820d84a09e2b548191d3b90100000000000000001000000000000000000000000000100000000000000000000000000040000000000000000000400100000000000000000000000000800000000000000000000000000020080000040000000000000000000000000000100000000000000000400000080000000000000000000000000000000000100000000000000000000000000000000000004000000000000000000000020000001000000000000000000000000000800000000000000000000000000000000004000000000000020000280000000000000800000500000100000000400000200000000000800000000000000000000000000000020000000000000000000000040000009032323137373831393836303031333938839a4aa383979f3e83024c39845ec6f2f487657a696c2e6d65a0f0a64ca3c939e2506d05505449b4caaa06eba7c86062997e6632b0ee3db977df88e284f1c803fa6f5a";
        let actual_borsh_proof = "0200000053000000f851a06adc4881ae9f2b2bbbf70a60e5b05f0734c02d731e80ac1503231d851b24ffe680808080808080a0103165b38cd8ad3ffa4b1de70e7391ac2c321ffe265bc77f2316ba33288c37178080808080808080b0010000f901ad30b901a9f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000";
        let actual_borsh_skip_bridge_call = "01";

        use borsh::BorshSerialize;
        let borsh_log_index = log_index.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_log_entry_data = log_entry.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_receipt_index = receipt_index.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_receipt_data = receipt_data.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_header_data = header_data.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_proof = proof.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_skip_bridge_call = true.try_to_vec().unwrap().encode_hex::<String>();

        assert_eq!(borsh_log_index, actual_borsh_log_index);
        assert_eq!(borsh_log_entry_data, actual_borsh_log_entry_data);
        assert_eq!(borsh_receipt_index, actual_borsh_receipt_index);
        assert_eq!(borsh_receipt_data, actual_borsh_receipt_data);
        assert_eq!(borsh_header_data, actual_borsh_header_data);
        assert_eq!(borsh_proof, actual_borsh_proof);
        assert_eq!(borsh_skip_bridge_call, actual_borsh_skip_bridge_call);

        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[cfg(feature = "expensive_tests")]
    #[test]
    fn verify_dumped_log_entries() {
        use indicatif::{ProgressBar, ProgressStyle};
        use near_sdk::VMConfig;
        use std::env;
        use std::fs;

        let mut vm_config = VMConfig::free();
        vm_config.limit_config.max_number_logs = u64::MAX;
        vm_config.limit_config.max_promises_per_function_call_action = u64::MAX;
        testing_env!(get_context(vec![], false), vm_config, Default::default());
        let contract = EthProver::init("ethbridge".to_string());

        let mut proofs = fs::read_dir(env::var("ETH_PROOF_DIR").unwrap())
            .unwrap()
            .map(|path| {
                let path = path.unwrap().path();
                let parts = path
                    .file_stem()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_string()
                    .split("_")
                    .map(|part| part.parse::<u64>().unwrap())
                    .collect::<Vec<_>>();
                ((parts[0], parts[1], parts[2]), path.display().to_string())
            })
            .collect::<Vec<_>>();
        proofs.sort_by_key(|s| s.0);

        #[derive(Debug, Deserialize)]
        struct Args {
            log_index: u64,
            log_entry_data: Hex,
            receipt_index: u64,
            receipt_data: Hex,
            header_data: Hex,
            proof: Vec<Hex>,
            skip_bridge_call: bool,
        }

        let bar = ProgressBar::new(proofs.len() as _);
        bar.set_style(ProgressStyle::default_bar().template(
            "[elapsed {elapsed_precise} remaining {eta_precise}] Verifying {bar} {pos:>7}/{len:>7}",
        ));

        for filename in proofs.iter() {
            let filename = filename.1.to_string();
            let args: Args = serde_json::from_reader(
                std::fs::File::open(std::path::Path::new(&filename)).unwrap(),
            )
            .unwrap();
            if let PromiseOrValue::Value(true) = contract.verify_log_entry(
                args.log_index,
                args.log_entry_data.0,
                args.receipt_index,
                args.receipt_data.0,
                args.header_data.0,
                args.proof.iter().map(|p| p.0.clone()).collect(),
                true,
            ) {
            } else {
                panic!();
            }
            bar.inc(1);
        }
        bar.finish();
    }
}
