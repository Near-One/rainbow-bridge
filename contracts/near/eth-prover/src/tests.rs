#[cfg(test)]
mod tests {
    use crate::EthProver;
    use hex::{FromHex, ToHex};
    use near_sdk::PromiseOrValue;
    use rlp::RlpStream;
    use serde::{Deserialize, Deserializer};

    #[derive(Debug)]
    struct Hex(pub Vec<u8>);

    impl<'de> Deserialize<'de> for Hex {
        fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
        where
            D: Deserializer<'de>,
        {
            let mut s = <String as Deserialize>::deserialize(deserializer)?;
            if s.starts_with("0x") {
                s = s[2..].to_string();
            }
            if s.len() % 2 == 1 {
                s.insert_str(0, "0");
            }
            Ok(Hex(Vec::from_hex(&s).map_err(|err| {
                serde::de::Error::custom(err.to_string())
            })?))
        }
    }

    // TESTS

    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.near".to_string(),
            signer_account_id: "bob.near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "carol.near".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            epoch_height: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
        }
    }

    #[test]
    fn storage_proof_test() {
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        let state_key = Vec::from_hex("0000000000000000000000000000000000000000000000000000000000000000").unwrap();
        let state_data = Vec::from_hex("c6cde7c39eb2f0f0095f41570af89efc2c1ea828").unwrap();
        let header_data = Vec::from_hex("f9021aa0f779e50b45bc27e4ed236840e5dbcf7afab50beaf553be56bf76da977e10cc73a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d493479452bc44d5378309ee2abf1539bf71de1b7d7be3b5a014c996b6934d7991643669e145b8355c63aa02cbde63d390fcf4e6181d5eea45a079b7e79dc739c31662fe6f25f65bf5a5d14299c7a7aa42c3f75b9fb05474f54ca0e28dc05418692cb7baab7e7f85c1dedb8791c275b797ea3b1ffcaec5ef2aa271b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000903234373439353837313930323034343383890fe68395ba8e82d0d9845dd84a079150505945206e616e6f706f6f6c2e6f7267a0a35425f443452cf94ba4b698b00fd7b3ff4fc671dea3d5cc2dcbedbc3766f45e88af7fec6031063a17").unwrap();
        let proof = vec![
            vec![
                Vec::from_hex("f90211a06da684a4b1ae35f910cec80faf688fa5c8a2632901e73e7fa1c04a870b558496a0e69601a0efa8ad4bcc6595b1e19b97a3c00ba2c19879c2c66137e2a08189d9a3a04ced4d17506ed50c801905b03ea4dbde8bd759009ef3f6013c5b442c92fa2c7ba0a7d452745fb3b78e61e39e5f4f04489e68e5dc52c6b340e2b5ba232e1783ed27a0f7a996ae616a90dbe518e68513afb6e6467fff4ca88849fd41e428bf6e175cdca09fe2453c12693cf21ef644c239e5e080b14a704b462b5b4b1301e8303d3206c1a0496894ac9e734d1f524179f7ac1d8dbc927a53a1913404bd55ff8d57c6822e07a03783d4dc104275ecfc9899d9a5196d1869becdbc62f96445f756a15742543015a0a4128b854c7e611e3bb44f67827da7a6df9973a36131c7de3e9f43811838b635a01d2896d4f2fe153b3bca2eb3d11dccb10bdf757c6f37ef0eca5f719a1a1a2b90a0f2400c6971d174eea97ba03943c3367653f723286800894b6fc5f8d87fa7f9a5a06f5643a3b2f3ea5620f170b1a268c0ee5d2c511eccabd91127f7e890dba871c9a0eded85bfd8210c481e8ae49cc50939ae1498121500c6b027358fa8aea104b94ba0befdc137cc3ec14d2737c96ede4d9b968cf9baef9552a8a73abbfffe6d3628c0a01ce85653ab3e9ecd8ae1a53cc095d860aa84836e863cafd12c3a680911bf5056a0a60cbafa1cecd9bbacb391b7d12cba81a62cca2e7700105c89db423d0c85143f80").unwrap(),
                Vec::from_hex("f90211a0fc58c574446ac34ccbbb860c26d9f86c6b772aa1c37899d767dcf6cc38d82c65a060f0f5498f8be8e53b4ae0e53a514051d1be17860b09b623fa17f8476fb9c8c9a027980d57676ca54fd49e150d049c05b0f8cc7a0f03c5f7c60d3ee54f75f079f3a0b82245433e1864c6811bfc57533de251903c3b5444ea15cef579eed586c94710a09ee00976f7fbd0bf624c3ab4e1f22e1ab63b68c93c2ec26aa5be1c1b21bd5a61a0dc986693273a9819c33cace8ed8024d9e7affea56513700bc140020935a5df73a0fe43342908e3c4ca48f8cadb48513eef5dae199c626f6a7ce2d77f3a431b66f4a08d3a30c3bb7ade097ec2b598c40c3aaa32621617758718a9f00c2eeb46fce712a0e1364f136b31cdf1f0a1fde3ba01ce8231e6898680209ae22bc58004cff43ec5a01a44f78abfb819cad1d0587ba6867ed963426ec44ff96bc44057e422a8bf65e7a0193123b46f3d80cacfc80fb18b028de4f0b1af8c923d127a4174b29908738e6ba059d5a2cca70017e455fe89dcc28a687d2d4941f510346c56ea4d3fc0761dc601a094e4363073877b61c3e83658555067a1dc38f90a49e378a61550f610e964efb4a0e1b70fc9eade8f6f16e308c06c9a50fe74a9e5b3c77d60f544b309bbcbf2956ca062917085c2990f5e84115b051653581faab9c6d603957f20f9a61543f69c1bdea0410f29aa5d7a384e7c1ba6af650d19c8af1f8323b4b7372f9204c96c0630314980").unwrap(),
                Vec::from_hex("f90211a07415b0032a3622c6f4f39ecb32aca26c304eceb5decb7a3244039ac7d88e55e9a06ea63f23dd3d01528d4702ef9fbc41b7fbe4c1912a44495383d3c91c5f37f4d7a0beeff0744a0c1d9f4aac797687e5a3209cc8e15f9361f46b0d005d0bec5b6fc5a0ef506e79abfce17bb1192e4241159900ee953ecb650eeca0415a4cdabde93731a0fca50f3597a52f19f1eeb11bed8a6d4a1ca41540902c8b93a1d09cb2611efec1a084405b65ef59c04e275269f9f0122b4e610e773b1812fccaecbed68ccb979075a083df23af69d32a8078b93ec1e8b57379741f7b85f7aa6a97aedcd1d173246e88a0bf350db71af528dfd6a7a045f3bf65ad68fed9fbd54ef9eb231f7765a5fbd08ba099a8d16dd6af1894ff6116f8e0b151abcd453da17da677a52be4970d92202385a0f019a467e8878a3abc51d424398d04ce4073e420fcb83a470245eafc2af31898a0b539b6f0529417f5c70ff4a3e28da5690a8d5d0f568410e8cef10a21a1894511a073bed577456f5d6e0c8a9435fd49e01df5d7f274f49d47e4fdbd5a2c27014744a005ae98d5310a69d88707e713a668a8452d36f10e3eb7cd60d20aec2c86ba1623a0651257b62c59d35ddc8aad24c5a7ed912fa99581fddb8cd6dfa9f9ae003214ada013ec103f015665cbd974babd39df410041c7d39124eb82ba0a6a971bfe2e77d6a0ce0909cebe2ecd24e0452112e1d7b517d72879d4f5e919b83bca08cb48cbb02b80").unwrap(),
                Vec::from_hex("f90211a0c88584e3bdaf7b19b2405a47c883af7e54bfe8511ab8bdfb0e825abfeb791dfda046936e9b216d6527289aee27790946b8782e154017e2ecb8b160f8e3a31a9613a0442d97c4f435311b3c0c297c208eb24970e97ec62f8a8261e9e943aa1d45c546a04ee8dc3cdfbfbcba1cbf61a05d6a0f80d127f0f31c86339d91b71308cc953154a01bb10c67b74b9db00912bb419a38bfe99618935a501a515da6885c2908fea9a2a07ae0d36d4790daf5438aa96ffcfb863e32320fde09c835f5c7d6ca87887e37cca01795fa7fad5abc4ede01ede93e2f032fc156d64491fe7c647939e99c9b873b77a04970cdb54960f77f55b154a1d38871f0a25d9bce0f1b045038fd6a00a8373d40a02c417e76ef8b4d8449b321cabfdca5d02756282ddef15270d63491062bf7b884a00abb7baef67a8ae2508cda1c4d2fc7081653b3900771c23b77e67855fdc51d2aa06faabd7c579cbd9b6d50e98d9334750b803d1ee6e89f99ae523f33501ab7d86ba031f798469f81e624be0686ab380a7c1cb9d88721a00f41317d8aee58cfbc8e34a045d4838f8defb5654252b3338eaeb185bf3b753171fb3e7671f0b6ed916b3361a05a832ca483f697163862aaccd2c16e854030fdd92ae1a8669c4ce04b08262a13a0246124f6bf4d36baed7b2af1a5984a10e84663d73e52dd5e97f78882327e9fdea09c6f764385a2ab719128b25df455a843e45b934593397861d9225cc577f22ccb80").unwrap(),
                Vec::from_hex("f90211a0c3386c126a2c9c89df71bedf5aebf6fa9200adc5481b2c88f99dc3ec4ed08361a009abb920d08bedd4b5c6a1bcba3ae05a3cd5a73f8c79a211efea281fcb15cc1fa0913856631a06a4489bb1197a5e835b1aced467db08a1905d9dc8ce0aed35e8c9a0c97977501053a8f5e4cb2e79922b80ccd730c64678ed30008ce2d34132c8323ea0bc3fc049786d72a04304dce5424d8f8d396fab4504464a9cd42b29efdeb53333a09339d320d842ce01543c386cc340f1fd0c465fc41eb5b73da5e4b8fe6f59f156a0c1fd6b5f01a29161ae3a7bddd1cdf1aeb462e925ba8ab9bf1d8f0f2ae6d2a876a0f8326e8e98e1aea9ce92d31c14af097c034782d0d7fb9a459fe67997efd4b95aa0f3f14dde1c7293e02565f4f449192da7168431f9ba1d41d205ec32ae93c09fd5a0bc64b7b16fb3f422860148de5404efe2fbee8b1661e4b727d3a579b65e8a42efa0f229916d7de59209c2ac599c779284e9959734cca3469dd53286d7249717f57fa0279d4591c82a7af4b68e3b5fddc840ec994ae5c5219244dd9f0e19fc7fa3fa4ea0f0d0cab680871dfb611e03d1391727818ab19d414cc09335e77b1ef8031744e9a07bf44521cde6f57fa06a880d0a98e0a52e8bc0eca632d61d019d067fb69d7e96a07d0d659faf79d7ec17ac7703da235823eedd254f75f7627989666681d0d75a99a0dcf849eabea12da3f89557d43523fdf595f092b4d27f2cb89f00d9c5c98df9e480").unwrap(),
                Vec::from_hex("f8718080a09be0d37160b689607ad2e25975264d71e476c7a7f48cef1ca5717349f5bd088b808080808080808080a083292f658ba0ac110a38e8b499a2e3fb7353b5f1c69c11d10593d4f7b54af917a0de64a3a75f4323d8f7c9db0c643ef1c2bf521e28ad8540271be9d4e7b9da198a808080").unwrap(),
                Vec::from_hex("f59e20d9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5639594c6cde7c39eb2f0f0095f41570af89efc2c1ea828").unwrap(),
            ],
        ].iter().map(|node| {
            let mut stream = RlpStream::new();
            stream.begin_list(node.len());
            for item in node {
                stream.append(item);
            }
            stream.out()
        }).collect();

        // pub fn verify_state_entry(
        //     &self,
        //     #[serializer(borsh)] state_key: Vec<u8>,
        //     #[serializer(borsh)] state_data: Vec<u8>,
        //     #[serializer(borsh)] header_data: Vec<u8>,
        //     #[serializer(borsh)] proof: Vec<Vec<u8>>,
        //     #[serializer(borsh)] skip_bridge_call: bool,
        // ) -> PromiseOrValue<bool> {

        if let PromiseOrValue::Value(true) = contract.verify_state_entry(
            state_key,
            state_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn simple_tx_res() {
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        // Following data could be extracted by:
        // NODE_URL="https://mainnet.infura.io/v3/b5f870422ee5454fb11937e947154cd2" TX_HASH="0xb540248a9cca048c5861dec953d7a776bc1944319b9bd27a462469c8a437f4ff" EVENT_INDEX=0 node extract.js

        let log_index = 0;
        let receipt_index = 0;
        let header_data = Vec::from_hex("f9021aa0f779e50b45bc27e4ed236840e5dbcf7afab50beaf553be56bf76da977e10cc73a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d493479452bc44d5378309ee2abf1539bf71de1b7d7be3b5a014c996b6934d7991643669e145b8355c63aa02cbde63d390fcf4e6181d5eea45a079b7e79dc739c31662fe6f25f65bf5a5d14299c7a7aa42c3f75b9fb05474f54ca0e28dc05418692cb7baab7e7f85c1dedb8791c275b797ea3b1ffcaec5ef2aa271b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000903234373439353837313930323034343383890fe68395ba8e82d0d9845dd84a079150505945206e616e6f706f6f6c2e6f7267a0a35425f443452cf94ba4b698b00fd7b3ff4fc671dea3d5cc2dcbedbc3766f45e88af7fec6031063a17").unwrap();
        let receipt_data = Vec::from_hex("f901a60182d0d9b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000006cc5f688a315f3dc28a7781717a9a798a59fda7ba00000000000000000000000007e7a32d9dc98c485c489be8e732f97b4ffe3a4cda000000000000000000000000000000000000000000000000000000001a13b8600").unwrap();
        let log_entry = Vec::from_hex("f89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000006cc5f688a315f3dc28a7781717a9a798a59fda7ba00000000000000000000000007e7a32d9dc98c485c489be8e732f97b4ffe3a4cda000000000000000000000000000000000000000000000000000000001a13b8600").unwrap();
        let proof = vec![
        vec![
            Vec::from_hex("2080").unwrap(),
            Vec::from_hex("f901a60182d0d9b9010000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000408000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000010000000000000000000000000000000000000000000000000000000400000000000100000000000000000000000000080000000000000000000000000000000000000000000100002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000006cc5f688a315f3dc28a7781717a9a798a59fda7ba00000000000000000000000007e7a32d9dc98c485c489be8e732f97b4ffe3a4cda000000000000000000000000000000000000000000000000000000001a13b8600").unwrap(),
        ],
    ].iter().map(|node| {
        let mut stream = RlpStream::new();
        stream.begin_list(node.len());
        for item in node {
            stream.append(item);
        }
        stream.out()
    }).collect();

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn complex_tx_res() {
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        // Following data could be extracted by:
        // NODE_URL="https://mainnet.infura.io/v3/b5f870422ee5454fb11937e947154cd2" TX_HASH="0xa7e1633e8099ea2b72496207b76a0e04a761c52f48c82bfcf6b327495258e4e0" EVENT_INDEX=0 node extract.js

        let log_index = 0;
        let receipt_index = 190;
        let header_data = Vec::from_hex("f9021ea059822ac0f17af7578ac8cf2c655a4ccfb1f5622ecad88992a2522e91a3cc401da01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d4934794829bd824b016326a401d083b33d092293333a830a01f54c61cebc3d08954929f359668498e191c1a34adb47f5db2881d414b69631ca0adf860aabb9786198a7d91dec6514ecebfd5aba4565fb7a81f8e68cf819b3000a0dddbc1d4cc2f1f522a3ba1f627d7645945d4922d6eb82c318c7be64735ec0e0db901000416012000c9a88c580040302001880844228042b418e12800bd011510a9580700f15880012010400858c08042dab1408b200403c1484425ac90c800d02c0800050050c04b4cc4b01083211905c820409a000e0c1346200508024c8020c892907120102c0a2840332290050028808c2104611a0c90944a020c002853968810640c0190030c342500584004239a2704228212001dc80004016803a15610920180070c89000a802115094a4082450080522001318488a8098a08c28000188025580490a4aa00b2802012001050868800140d0fd20800d8200682226060119420049032000832001a4011780096081c7654002800100d9484102144ec889094a44a903233363631373837353134373338393883984f928398684283986153845eac64b1947070796520e4b883e5bda9e7a59ee4bb99e9b1bca0814ab4871d625ff894a6736dcf195f4ce1c0f5dd8a3d42a1e9587c2a9e1d522988dd7482ba86e3b14a").unwrap();
        let receipt_data = Vec::from_hex("f901a701839590b6b9010000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000001000000000000000000000000000000010000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000004000000000000000010000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000600000000000f89df89b945885d2a27bd4c6d111b83bc3fc359ed951e8e6f8f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000009b24ee0bfbf708b541fb65b6087d6e991a0d11a8a00000000000000000000000005a012de1a4c89b496e0a276158552abe6f843a6fa0000000000000000000000000000000000000000000000001135631d5283a4000").unwrap();
        let log_entry = Vec::from_hex("f89b945885d2a27bd4c6d111b83bc3fc359ed951e8e6f8f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000009b24ee0bfbf708b541fb65b6087d6e991a0d11a8a00000000000000000000000005a012de1a4c89b496e0a276158552abe6f843a6fa0000000000000000000000000000000000000000000000001135631d5283a4000").unwrap();
        let proof = vec![
        vec![
            Vec::from_hex("c684a63b18c933f0b45d6863ec63d5beb49e191992479fe3cbf1dc6709661337").unwrap(),
            Vec::from_hex("297cb12d9b6b25bff0bd3199bfd2fdb4b3fca45416ecc355958b68dc1b7bc7a3").unwrap(),
            Vec::from_hex("870bde7cc109d51463b1b8e77ebb36cb4021ddc7df0fd31c3140cad3260236e8").unwrap(),
            Vec::from_hex("8ddcf32ce5a1ac912bddc28f2f25df0921aaff8f100f2979028b27baa5b191f1").unwrap(),
            Vec::from_hex("4de7d3b04b549af847ffcc757f8aa121b02bd00c1233e90547fac99da7049e19").unwrap(),
            Vec::from_hex("206564eec53442ea3334438820c75c1f8bdb617430956f07a08e66f5990458ae").unwrap(),
            Vec::from_hex("b11876d993891898b6397d0fa744783ba5bf35e79a329c7b9710e9026c2957c8").unwrap(),
            Vec::from_hex("719cc527cb7fcec3efaf017c5c4801609fa41572befae0468c24ac48fd389437").unwrap(),
            Vec::from_hex("e59bf6fa8f9359d07651b581b3875fc8aea5b85ba0eab9e23503dfa273b9b0f0").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("a123f503897e190fa46ac478716778ebff6c1661b676c910cb4d4c6764457e06").unwrap(),
            Vec::from_hex("4ca92d89e85b0bc5a8670844967a027f012db12fb027808532c0ad61a751747e").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("578357a5e1c44fdccf2cc34d27142b04ec433fe3c8bc57a35c4971f6a82a4da4").unwrap(),
            Vec::from_hex("4d6d3155937f76f01a359ebff4336a504ede8e283e555e1194468883854b7b11").unwrap(),
            Vec::from_hex("ce5478625cca3b625badaa26d231cbd072735b72307b7bce43a7917bd8ba04be").unwrap(),
            Vec::from_hex("66d11ae6215298daa654e04de8649aeb1e116f7138bf3d921c5cbe0a52589116").unwrap(),
            Vec::from_hex("e80733626a805d2974d9b97db52e18d2ce28f532f96552098bf0e656c6bb39a9").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("46935fcc8ffcc89c8eae03fef89ac9fbde75be14b64c810fb1447d328907456d").unwrap(),
            Vec::from_hex("15ec39ed1284cdf4840d6b7511ff34aed164fd9e4b920b1fdb6fde54958d3a17").unwrap(),
            Vec::from_hex("e02aae4672f8b80f468759b092e4eb809edc8cf4b513df11b21d4233556c0b4d").unwrap(),
            Vec::from_hex("0efe37f3d3919b0bed73152bee545e033eb1fad5ddd8e383747decfd5ae93231").unwrap(),
            Vec::from_hex("16616fa5c192ddf9d0c2e1b1d70dc02a83f490b7d729072ac129d9f58f1e166d").unwrap(),
            Vec::from_hex("edb363ac38c62779bf449b0a51bb0b79a9541e8e5b12a8660185fa729795bedc").unwrap(),
            Vec::from_hex("c59dfcdfefed6a01b761ffd820cec8b8f52d9cb287759441cbd73e2a78ba2416").unwrap(),
            Vec::from_hex("893e6dacc036de93725e0e5112d849a735837a94536635318227b448535c6eb2").unwrap(),
            Vec::from_hex("dd8b4c24d7246d9c3a86fef130a5a3bc53f10d1ab706789d6914b8580c4c0202").unwrap(),
            Vec::from_hex("17c0abe1c74e0d01db47e4e2f2d75555d0ea3a2fc590670186ac23dd31944ec0").unwrap(),
            Vec::from_hex("4535f5fc448300be236c1e7f28576296b449592f5adbac59bf35a40e2f7701be").unwrap(),
            Vec::from_hex("bbf8eca1063220d003071437da87689887491c999913f5aba6ed21915c78407c").unwrap(),
            Vec::from_hex("1875e64c3cb31254ff0cf8041d4053c33e3f6aad8faad2c9323729324eaf1a9e").unwrap(),
            Vec::from_hex("7546cbb2b0137e669738c5ab69fb2071f755b253468f90da48855d41411d2e77").unwrap(),
            Vec::from_hex("d9677df9ddf784f9d20f24737b40cb372478114b225df8af225c0f40aaa843f5").unwrap(),
            Vec::from_hex("5b34e3dcfa33c72c4645793531246a91b74af04d564eebd63d00d0e274880283").unwrap(),
            Vec::from_hex("").unwrap(),
        ],
        vec![
            Vec::from_hex("20").unwrap(),
            Vec::from_hex("f901a701839590b6b9010000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000001000000000000000000000000000000010000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000004000000000000000010000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000600000000000f89df89b945885d2a27bd4c6d111b83bc3fc359ed951e8e6f8f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000009b24ee0bfbf708b541fb65b6087d6e991a0d11a8a00000000000000000000000005a012de1a4c89b496e0a276158552abe6f843a6fa0000000000000000000000000000000000000000000000001135631d5283a4000").unwrap(),
        ],
    ].iter().map(|node| {
        let mut stream = RlpStream::new();
        stream.begin_list(node.len());
        for item in node {
            stream.append(item);
        }
        stream.out()
    }).collect();

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn complex_test2() {
        let log_index = 0;
        let receipt_index = 1;
        let header_data = Vec::from_hex("f9021aa0fbc31be764b2ba0eb7ee8ac2ce71743a9643772960eca29751c014e21de21278a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347945a0b54d5dc17e0aadc383d2db43b0a0d3e029c4ca0f35ea6f9f8a4a6bd6338ded9e4835c5111e3de7d78ec3869bba35e8db64f98a1a03990dcdacdec9c2626acb9b7c45c4fb5ddf62e61fd03151940f459da6f995345a0b23d76b7b3747e862bb148796a84697aed7ae4f493bdc6e8fd86fabc15c2076cb9010020e29a9a88c12d9ce049f610e00016230089010014ada31c62437913062aabdc310b8558216215f4045742123241a30d963087246804068307c1514017e839815c000020829cdc00eb84d10f87c0dd384d83a502822ae0289b28b40dc845307c536088a1125242c00788626840062910dd4e183418a2411c0ca1d412e0709cc70339c0052345e08920a15e05a6c264b10808375949a20c6ec6ce016204b50011077da58a0ac92e5a1e07a486512fb332d1239dd5e85890e0005863101c9108651430a0e300090a00945b4d13876310242804da061c2d149008910001340c61004c113565f1321cde85a24c3cf27dfa4450c84010d01156d0084fb4350886a8ea9032323433303231373839313735313932839a1acc839895ff839848c0845ec4709a906574682d70726f2d687a682d74303032a00bdd7eaec7aa518470d8fc2c9c3ce9b20ae81cbd6e9a7697e7b6955eafbe71448825e70b4c039f477c").unwrap();
        let receipt_data = Vec::from_hex("f901a70183012d99b9010000000000000000000000000000000000000001000000000000000000000000000000000000000000000002000000010000000000000000000000000000000000000000000008000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000400000000000000000000000000000000000000000000000000100000000000000000000004000080000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000adb2b42f6bd96f5c65920b9ac88619dce4166f94a0000000000000000000000000658a36d8f840f73207af8df717d12046b2c75969a000000000000000000000000000000000000000000000000000000000042c1d80").unwrap();
        let log_entry = Vec::from_hex("f89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000adb2b42f6bd96f5c65920b9ac88619dce4166f94a0000000000000000000000000658a36d8f840f73207af8df717d12046b2c75969a000000000000000000000000000000000000000000000000000000000042c1d80").unwrap();

        let proof = vec![
    vec![
        Vec::from_hex("7ea815c3bb71385b7a510e4982f8313c587df3e089ff5f10ef0b56c36071181a").unwrap(),
        Vec::from_hex("aed4d27efd05e63eef759ea509eab454e0af48bee830df3e35555bb0a286d231").unwrap(),
        Vec::from_hex("33e390a966c516979815c1f2017dbbced85a051ee1fa80f3e1ec53cf1c9cdd2a").unwrap(),
        Vec::from_hex("42b428567467e5185275855e1785c8b8d7f9bc3a43f1be769d770eea3fc20406").unwrap(),
        Vec::from_hex("6dddd3c9259c9ada25d4e3e6597e418c57cb02a161efbba40769e1d581abe20c").unwrap(),
        Vec::from_hex("e218b0ea18d0ecdaa79c39d116ca13b3d3d46681b6d05dcacc6240157b13fc11").unwrap(),
        Vec::from_hex("ec966a6c704f311620c3edad1afb82142ffe26e0c72e663bdd1b19395adbeac9").unwrap(),
        Vec::from_hex("648364b261369d14558bace2ba9ff2297140d175d126ec3523c6678d24186c78").unwrap(),
        Vec::from_hex("fa7687bf5494e940497877b0af984a3a6d2881540b38f3a7022a727541f7e640").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),

    ],
    vec![
        Vec::from_hex("").unwrap(),
        Vec::from_hex("b41ef42ebd5a54a9834eb215c8e3cbe05d71ced9ee5ff465801759362925099e").unwrap(),
        Vec::from_hex("65694c678def4a1be4a2c33fbe9a039028ba07239eea62cac48311aad9f6f744").unwrap(),
        Vec::from_hex("2788302a6da4394430ae76b909dcb3470562cc4f2beb34dd84910214098c2dd4").unwrap(),
        Vec::from_hex("dc2bca155d607e3ab7a50568ab6a5861730ee59aff6eb883a578c6766e318cb5").unwrap(),
        Vec::from_hex("17ccd6e58a09d12b854aa1dfd945e9ac4861ac61346326351c7807ed3a6cd166").unwrap(),
        Vec::from_hex("9c49c49ed1cc4713b965a2b469b8e00b2a4ec15fd738a58d70f57413c8543265").unwrap(),
        Vec::from_hex("52292a51a81001bd97ab317d573b43c00a2fe9cbe2b71e8b6f867fc71e3d9acc").unwrap(),
        Vec::from_hex("a6e6de2a96567b42ac6ddd29a46fa75fba4e3a6bd2edfdcc5102eaa030c821e0").unwrap(),
        Vec::from_hex("c9da26cf4ddb9aa33f52ab0e8c0da91dd56b0c346f804c5db1411167f32cf23a").unwrap(),
        Vec::from_hex("2cf55c3104a836212f679521a3e7ac2202180e2568186e09d419dec6af598830").unwrap(),
        Vec::from_hex("6b5b12b7e5858accef4ba7a9e243f0b7eac91aa4a5080bd7b68e0c64b5cedccf").unwrap(),
        Vec::from_hex("ed32579f4c42503e20c6b356228664c1d5e28f3237bf8e8878e53fe910e9a356").unwrap(),
        Vec::from_hex("ccf3014a6bccf8a6d0ed97fc0a7d4e53a3d1c75d784625c2e556c8dd5a9e5a06").unwrap(),
        Vec::from_hex("aab295d8f316e3bbb6e26d77ce71ea7d96f0c8b28aea132856291e46f4a653d8").unwrap(),
        Vec::from_hex("85b056f6837537036e5862e567beadc46c9c76bbfe43024cae7c561547fdcf2e").unwrap(),
        Vec::from_hex("").unwrap(),
    ],
    vec![
        Vec::from_hex("20").unwrap(),
        Vec::from_hex("f901a70183012d99b9010000000000000000000000000000000000000001000000000000000000000000000000000000000000000002000000010000000000000000000000000000000000000000000008000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000400000000000000000000000000000000000000000000000000100000000000000000000004000080000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f89df89b94dac17f958d2ee523a2206206994597c13d831ec7f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000adb2b42f6bd96f5c65920b9ac88619dce4166f94a0000000000000000000000000658a36d8f840f73207af8df717d12046b2c75969a000000000000000000000000000000000000000000000000000000000042c1d80").unwrap(),
    ],
    ];
        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        let proof = proof
            .iter()
            .map(|node| {
                let mut stream = RlpStream::new();
                stream.begin_list(node.len());
                for item in node {
                    stream.append(item);
                }
                stream.out()
            })
            .collect();

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[test]
    fn complex_test3() {
        let log_index = 0;
        let receipt_index = 0;
        let header_data = Vec::from_hex("f90211a0460c84f2877fd351416cc9207bbb140eda2a59f0501bda5d4e814e017024536fa01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347948595dd9e0438640b5e1254f9df579ac12a86865fa0c2377ee7587692810e987464064b2247c8d7d6ad0f9fce327bd27ad0c92a62afa0a4041a7e77fc216726e5015e6712d6434a1a4991781ed9478f5451ad5ac1e362a077ee012c7ec8a7a5cc6f8c7899e4176f8716ce11c637820d84a09e2b548191d3b90100000000000000001000000000000000000000000000100000000000000000000000000040000000000000000000400100000000000000000000000000800000000000000000000000000020080000040000000000000000000000000000100000000000000000400000080000000000000000000000000000000000100000000000000000000000000000000000004000000000000000000000020000001000000000000000000000000000800000000000000000000000000000000004000000000000020000280000000000000800000500000100000000400000200000000000800000000000000000000000000000020000000000000000000000040000009032323137373831393836303031333938839a4aa383979f3e83024c39845ec6f2f487657a696c2e6d65a0f0a64ca3c939e2506d05505449b4caaa06eba7c86062997e6632b0ee3db977df88e284f1c803fa6f5a").unwrap();
        let receipt_data = Vec::from_hex("f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000").unwrap();
        let log_entry = Vec::from_hex("f89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000").unwrap();
        let proof = vec![
    vec![
        Vec::from_hex("6adc4881ae9f2b2bbbf70a60e5b05f0734c02d731e80ac1503231d851b24ffe6").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("103165b38cd8ad3ffa4b1de70e7391ac2c321ffe265bc77f2316ba33288c3717").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
        Vec::from_hex("").unwrap(),
    ],
    vec![
        Vec::from_hex("30").unwrap(),
        Vec::from_hex("f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000").unwrap(),
    ]];

        let proof: Vec<Vec<u8>> = proof
            .iter()
            .map(|node| {
                let mut stream = RlpStream::new();
                stream.begin_list(node.len());
                for item in node {
                    stream.append(item);
                }
                stream.out()
            })
            .collect();

        let actual_borsh_log_index = "0000000000000000";
        let actual_borsh_log_entry_data = "9d000000f89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000";
        let actual_borsh_receipt_index = "0000000000000000";
        let actual_borsh_receipt_data = "a9010000f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000";
        let actual_borsh_header_data = "14020000f90211a0460c84f2877fd351416cc9207bbb140eda2a59f0501bda5d4e814e017024536fa01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347948595dd9e0438640b5e1254f9df579ac12a86865fa0c2377ee7587692810e987464064b2247c8d7d6ad0f9fce327bd27ad0c92a62afa0a4041a7e77fc216726e5015e6712d6434a1a4991781ed9478f5451ad5ac1e362a077ee012c7ec8a7a5cc6f8c7899e4176f8716ce11c637820d84a09e2b548191d3b90100000000000000001000000000000000000000000000100000000000000000000000000040000000000000000000400100000000000000000000000000800000000000000000000000000020080000040000000000000000000000000000100000000000000000400000080000000000000000000000000000000000100000000000000000000000000000000000004000000000000000000000020000001000000000000000000000000000800000000000000000000000000000000004000000000000020000280000000000000800000500000100000000400000200000000000800000000000000000000000000000020000000000000000000000040000009032323137373831393836303031333938839a4aa383979f3e83024c39845ec6f2f487657a696c2e6d65a0f0a64ca3c939e2506d05505449b4caaa06eba7c86062997e6632b0ee3db977df88e284f1c803fa6f5a";
        let actual_borsh_proof = "0200000053000000f851a06adc4881ae9f2b2bbbf70a60e5b05f0734c02d731e80ac1503231d851b24ffe680808080808080a0103165b38cd8ad3ffa4b1de70e7391ac2c321ffe265bc77f2316ba33288c37178080808080808080b0010000f901ad30b901a9f901a60182574ab9010000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000080000000000000000000000000002008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000010000000000000000000020000000000080000000000000000000000000000000000000000000000000000004000000f89df89b94d26114cd6ee289accf82350c8d8487fedb8a0c07f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa00000000000000000000000002c7116a63ab91084a7a5d6fef2e4eda0c84487afa00000000000000000000000007d3cd5685188c6aa498697db91ca548a1249863ea0000000000000000000000000000000000000000000000001158e460913d00000";
        let actual_borsh_skip_bridge_call = "01";

        use borsh::BorshSerialize;
        let borsh_log_index = log_index.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_log_entry_data = log_entry.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_receipt_index = receipt_index.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_receipt_data = receipt_data.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_header_data = header_data.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_proof = proof.try_to_vec().unwrap().encode_hex::<String>();
        let borsh_skip_bridge_call = true.try_to_vec().unwrap().encode_hex::<String>();

        assert_eq!(borsh_log_index, actual_borsh_log_index);
        assert_eq!(borsh_log_entry_data, actual_borsh_log_entry_data);
        assert_eq!(borsh_receipt_index, actual_borsh_receipt_index);
        assert_eq!(borsh_receipt_data, actual_borsh_receipt_data);
        assert_eq!(borsh_header_data, actual_borsh_header_data);
        assert_eq!(borsh_proof, actual_borsh_proof);
        assert_eq!(borsh_skip_bridge_call, actual_borsh_skip_bridge_call);

        testing_env!(get_context(vec![], false));

        let contract = EthProver::init("ethbridge".to_string());

        if let PromiseOrValue::Value(true) = contract.verify_log_entry(
            log_index,
            log_entry,
            receipt_index,
            receipt_data,
            header_data,
            proof,
            true,
        ) {
        } else {
            panic!();
        }
    }

    #[cfg(feature = "expensive_tests")]
    #[test]
    fn verify_dumped_log_entries() {
        use indicatif::{ProgressBar, ProgressStyle};
        use near_sdk::VMConfig;
        use std::env;
        use std::fs;

        let mut vm_config = VMConfig::free();
        vm_config.limit_config.max_number_logs = u64::MAX;
        vm_config.limit_config.max_promises_per_function_call_action = u64::MAX;
        testing_env!(get_context(vec![], false), vm_config, Default::default());
        let contract = EthProver::init("ethbridge".to_string());

        let mut proofs = fs::read_dir(env::var("ETH_PROOF_DIR").unwrap())
            .unwrap()
            .map(|path| {
                let path = path.unwrap().path();
                let parts = path
                    .file_stem()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .to_string()
                    .split("_")
                    .map(|part| part.parse::<u64>().unwrap())
                    .collect::<Vec<_>>();
                ((parts[0], parts[1], parts[2]), path.display().to_string())
            })
            .collect::<Vec<_>>();
        proofs.sort_by_key(|s| s.0);

        #[derive(Debug, Deserialize)]
        struct Args {
            log_index: u64,
            log_entry_data: Hex,
            receipt_index: u64,
            receipt_data: Hex,
            header_data: Hex,
            proof: Vec<Hex>,
            skip_bridge_call: bool,
        }

        let bar = ProgressBar::new(proofs.len() as _);
        bar.set_style(ProgressStyle::default_bar().template(
            "[elapsed {elapsed_precise} remaining {eta_precise}] Verifying {bar} {pos:>7}/{len:>7}",
        ));

        for filename in proofs.iter() {
            let filename = filename.1.to_string();
            let args: Args = serde_json::from_reader(
                std::fs::File::open(std::path::Path::new(&filename)).unwrap(),
            )
            .unwrap();
            if let PromiseOrValue::Value(true) = contract.verify_log_entry(
                args.log_index,
                args.log_entry_data.0,
                args.receipt_index,
                args.receipt_data.0,
                args.header_data.0,
                args.proof.iter().map(|p| p.0.clone()).collect(),
                true,
            ) {
            } else {
                panic!();
            }
            bar.inc(1);
        }
        bar.finish();
    }

    use near_sdk::VMConfig;

    #[test]
    pub fn test_verify_proof() {
        let vm_config = VMConfig::free();
        testing_env!(get_context(vec![], false), vm_config, Default::default());

        let expected_value = "f902a60183af4adfb9010000000000000000000000000000000000000000000000000000000000000000000800010000000000000002000100000000000000000000000000000000000000000000000000000008000008000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000010000000040000000000000000000000000000000200000000010000000000000000000000000000000000200080000000202000000000000000000000000000004000000000000002000000000000000000000000000000000000080000000000000000000000000000000000000000000200000004000000000000000000000000000000f9019bf89b94a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000c22df065a81f6e0107e214991b9d7fb179d401b3a000000000000000000000000023ddd3e3692d1861ed57ede224608875809e127fa00000000000000000000000000000000000000000000000000000000005f5e100f8fc9423ddd3e3692d1861ed57ede224608875809e127ff863a0dd85dc56b5b4da387bf69c28ec19b1d66e793e0d51b567882fa31dc50bbd32c5a0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48a0000000000000000000000000c22df065a81f6e0107e214991b9d7fb179d401b3b8800000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a6d616b6b652e6e65617200000000000000000000000000000000000000000000";
        let expected_root = "73733f420161b4189ea48140489bfada55d485fd580ab7e6f0f4b6de229f5177";
        let key = "820137";
        let proof_rlp = vec!["f90131a07dc6deefc13acb3456defc30824e9ba7d344e0fed67d6fe918a845ac6c7ff68ca00743abb9e8a2419e731aabac46e87dd9166ef04f4c0e17b607f699169fd16effa0de6439dd92daf3fe5ae984f9176a1d53f0ab2c03a73ea9ee2c94c79a87b82386a08eccde52f7cdcfa2207e2e8256bbd05a78fbab4f1b564a98a7f5b259b9fcb05da0196a72fd5279acc9146896618d5a134398bfc5d84063bcb2dc4f206bceb1526fa0daa3100c65bc47d986741898d7dfa1cc2f944d9f621b33a53d52047d98ab6e84a0126a9c69a2fb01312dffd739ee2a86c15106497d5e53314875e3a83c915b40c3a0b89b77f6776de33f0d291891d4271546d3b4946325f6fa66d38a1618f699b7b0a06b4f2fac50925da7c11ddac2321257cf157d426bffedcce8c3e999f8dd3902ff8080808080808080", "f871a073170337a44a638efb6d735150b3a06346b54b6176c9424307e6c1f4a4604131a0409f60141274adbaf1fd8808c432c599025a80763a61aca8710ba5416436c885a064d0127fe80ad8301e425eece21dd4811515312fad7e95b9ad4f853d003582a88080808080808080808080808080", "e4820001a022d9ed1b1940164d904d587080c9ca1d5ebb7e711211233bee7ecf6f0fba3d8e", "f8d1a0af41ab83382da16fba21a258c18a231957c14eb91ede9b75b089d37474efe1b8a0102af48a2d48aa200cb90bafdb43c3845ed09e2d34f333944ac7c172f2becec4a0644f776baaf4dd2a45e817c3b70ed881419f31d966debf0e2dac62426b1308eea08498703814dfa09c76b9f8dde1d5e3865b92b805e9ffd77d12cd8221497fe604a02a6a5cc557e67488aef767895f2ad789fa339aab229d7e94b78d6a8187989d3ea002ec005b9dafdfd58601cd6dc96fd958a8681981442c485c87142ae85acc1fd28080808080808080808080", "f90211a02e04ddc4ab28665d70404d04601838d03b219207d68a477e086144d5452b035ea07458b1e7734dcde7a48e763f57b533d39a9893b2fd05ece758eb95c45230b69aa05ce53207da7cb7efdfa60bfc57dc23a5469d2823ac6d94377fda37d7d6e77a23a0ba360fa8bb757bec0086b0d2973bb39de6b874ae3558e0b91eb54579022bc68fa023068af8cff2927c6c437840b4bee730c5ef2d918c0bb086b453da9071f3e3a8a05a6cb3455636113070e724682c1e852b564bc26195690b57adf95b03e453fb56a090e6afaa341c8c8583ba621e0f4369e0a36e488d167061bf0627c8de8e4b1b53a0c974bc6676b17c2e0e0016b86e2261cc69fa10b06ad22938f851674c853face6a0134724224ee173faf5807c3b963e4aff5d8435c2296230ba6fbdf222262ee7a5a0ea6f74b84a4ee7f7d557bb27e61c75ae30ead9092faab3b441c4e5055c8768d7a09e5ab3942cfe8410180611c7eddb2364ba2022e53971b50250636f2576f1528fa0fe27620c114d5ce5b8c96859b754cf0a40a9a0cb7a6c88a492ca906b09db6c5aa023558ac1d7facb4cb81d5ced13c9126b70a898a81b63fe52117792ed5bcadb06a00b52d0a4cd96595521a0783e6f17de8b9bdd15f1e50ab8b51179a98ae6df18e5a0462c433d431953bcead5900c4b372c60b20280d05366fe48de6384152cfc8da9a0a5a9b086a22dc344a40496a9de4ebab616fa87dfc77760eef7939ba51dd193cd80", "f902ad20b902a9f902a60183af4adfb9010000000000000000000000000000000000000000000000000000000000000000000800010000000000000002000100000000000000000000000000000000000000000000000000000008000008000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000010000000040000000000000000000000000000000200000000010000000000000000000000000000000000200080000000202000000000000000000000000000004000000000000002000000000000000000000000000000000000080000000000000000000000000000000000000000000200000004000000000000000000000000000000f9019bf89b94a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48f863a0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa0000000000000000000000000c22df065a81f6e0107e214991b9d7fb179d401b3a000000000000000000000000023ddd3e3692d1861ed57ede224608875809e127fa00000000000000000000000000000000000000000000000000000000005f5e100f8fc9423ddd3e3692d1861ed57ede224608875809e127ff863a0dd85dc56b5b4da387bf69c28ec19b1d66e793e0d51b567882fa31dc50bbd32c5a0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48a0000000000000000000000000c22df065a81f6e0107e214991b9d7fb179d401b3b8800000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000a6d616b6b652e6e65617200000000000000000000000000000000000000000000"];

        let expected_root = hex::decode(expected_root).unwrap().into();
        let key = hex::decode(key).unwrap();
        let proof = proof_rlp
            .into_iter()
            .map(|x| hex::decode(x).unwrap())
            .collect();
        let expected_value = hex::decode(expected_value).unwrap();

        assert_eq!(
            EthProver::verify_trie_proof(expected_root, key, proof),
            expected_value
        );
    }
}
